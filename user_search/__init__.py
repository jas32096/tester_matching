import sqlalchemy as sa
from sqlalchemy.ext.automap import automap_base, generate_relationship as generate_relationship_real
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.hybrid import hybrid_property

from pathlib import Path

def generate_relationship(base, direction, return_fn, attrname, local_cls, referred_cls, **kwargs):
    # Prevent creation of errant collection
    if attrname == 'testerexperience_collection':
        return
    return generate_relationship_real(base, direction, return_fn, attrname, local_cls, referred_cls, **kwargs)


engine = sa.create_engine(f"sqlite:///{Path(__file__).parent / 'data.db'}")
metadata = sa.MetaData()
metadata.reflect(engine)
Base = automap_base(metadata=metadata)

class TesterExperience(Base):
    __tablename__ = 'tester_experience'

    # Fake composite primary key to map view
    testerId   = sa.Column(sa.Integer, sa.ForeignKey('tester.testerId'), primary_key=True)
    experience = sa.Column(sa.Integer, primary_key=True)
    tester = sa.orm.relationship('Tester', back_populates='tester_experience', viewonly=True)

# Needed to overide the autogenerated relationship
class Tester(Base):
    __tablename__ = 'tester'

    tester_experience = sa.orm.relationship('TesterExperience', back_populates='tester', viewonly=True, uselist=False)
    experience = association_proxy('tester_experience', 'experience')

    @hybrid_property
    def fullName(self):
        return self.firstName + ' ' + self.lastName

class Device(Base):
    __tablename__ = 'device'

    @hybrid_property
    def description_lower(self):
        return self.description.lower()

    @description_lower.expression
    def description_lower(self):
        return sa.func.lower(self.description)


Base.prepare(engine, classname_for_table=lambda base,tablename,table: tablename.capitalize(), generate_relationship=generate_relationship)
session = sa.orm.Session(engine)

__all__ = ['session', 'TesterExperience', 'Tester', 'Device']

# Autogen classes for relected tables
from sys import modules
current_module = modules[__name__]
for class_name, model in Base.classes.items():
    __all__.append(class_name)
    setattr(current_module, class_name, model)
